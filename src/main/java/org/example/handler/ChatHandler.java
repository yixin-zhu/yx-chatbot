package org.example.handler;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.apache.commons.collections4.CollectionUtils;
import org.example.DTO.SearchResult;
import org.example.client.DeepSeekClient;
import org.example.service.HybridSearchService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Service;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

/**
 * 聊天处理服务
 * 负责处理WebSocket聊天消息和管理对话历史
 * 
 * @author Generated by Assistant
 */
@Service
public class ChatHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(ChatHandler.class);
    private final RedisTemplate<String, String> redisTemplate;
    private final HybridSearchService searchService;
    private final DeepSeekClient deepSeekClient;
    private final ObjectMapper objectMapper;
    
    // 用于存储每个会话的完整响应
    private final Map<String, StringBuilder> responseBuilders = new ConcurrentHashMap<>();
    // 用于跟踪每个会话的响应完成状态
    private final Map<String, CompletableFuture<String>> responseFutures = new ConcurrentHashMap<>();
    // 停止标志 - 简单方案
    private final Map<String, Boolean> stopFlags = new ConcurrentHashMap<>();

    public ChatHandler(RedisTemplate<String, String> redisTemplate,
                      HybridSearchService searchService,
                      DeepSeekClient deepSeekClient) {
        this.redisTemplate = redisTemplate;
        this.searchService = searchService;
        this.deepSeekClient = deepSeekClient;
        this.objectMapper = new ObjectMapper();
    }

    public void processMessage(String userId, String userMessage, WebSocketSession session) {
        String sessionId = session.getId();
        try {
            // 1. 准备阶段：获取会话ID与历史记录
            String conversationId = getOrCreateConversationId(userId);
            List<Map<String, String>> history = getConversationHistory(conversationId);
            // 2. 检索阶段：带权限的混合搜索与上下文构建
            List<SearchResult> searchResults = searchService.searchWithPermission(userMessage, userId, 5);
            String context = buildContext(searchResults);
            // 3. 状态管理：使用 StringBuilder 累积完整回答（用于后续存入 Redis）
            StringBuilder fullResponse = new StringBuilder();
            // 初始化停止标志
            stopFlags.put(sessionId, false);
            // 4. 调用 AI：流式处理（不再需要后台线程轮询！）
            deepSeekClient.streamResponse(userMessage, context, history,
                    // 吐字回调：onChunk
                    chunk -> {
                        if (Boolean.TRUE.equals(stopFlags.get(sessionId))) return;
                        fullResponse.append(chunk);
                        sendResponseChunk(session, chunk);
                    },
                    // 完成回调：onComplete (核心改进点！)
                    () -> {
                        logger.info("DeepSeek 响应流自然结束 - 会话: {}", sessionId);
                        String completeContent = fullResponse.toString();
                        // 持久化对话：更新 Redis 历史
                        updateConversationHistory(conversationId, userMessage, completeContent);
                        // 发送完成信号给前端
                        sendCompletionNotification(session);
                        // 清理临时状态
                        cleanupSession(sessionId);
                    },
                    // 异常回调：onError
                    error -> {
                        logger.error("流处理过程中发生错误: {}", error.getMessage());
                        handleError(session, error);
                        cleanupSession(sessionId);
                    }
            );
        } catch (Exception e) {
            logger.error("消息处理链发起失败", e);
            handleError(session, e);
            cleanupSession(sessionId);
        }
    }

    private void cleanupSession(String sessionId) {
        stopFlags.remove(sessionId);
        // 如果你之前的 responseBuilders 还留着，记得也在这里 remove
        logger.debug("已清理 Session {} 的临时状态", sessionId);
    }

    private String getOrCreateConversationId(String userId) {
        String key = "user:" + userId + ":current_conversation";
        String conversationId = redisTemplate.opsForValue().get(key);
        
        if (conversationId == null) {
            conversationId = UUID.randomUUID().toString();
            redisTemplate.opsForValue().set(key, conversationId, Duration.ofDays(7));
            logger.info("为用户 {} 创建新的会话ID: {}", userId, conversationId);
        } else {
            logger.info("获取到用户 {} 的现有会话ID: {}", userId, conversationId);
        }
        
        return conversationId;
    }

    private List<Map<String, String>> getConversationHistory(String conversationId) {
        String key = "conversation:" + conversationId;
        String json = redisTemplate.opsForValue().get(key);
        if (json == null) {
            logger.debug("会话 {} 没有历史记录", conversationId);
            return new ArrayList<>();
        }
        try {
            return objectMapper.readValue(json, new TypeReference<>() {});
        } catch (JsonProcessingException e) {
            logger.error("解析对话历史出错: {}, 会话ID: {}", e.getMessage(), conversationId, e);
            return new ArrayList<>();
        }
    }

    private void updateConversationHistory(String conversationId, String userMessage, String response) {
        String key = "conversation:" + conversationId;
        List<Map<String, String>> history = getConversationHistory(conversationId);
        
        // 获取当前时间戳
        String currentTimestamp = java.time.LocalDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss"));

        String now = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);

        history.add(Map.of("role", "user", "content", userMessage, "timestamp", now));
        history.add(Map.of("role", "assistant", "content", response, "timestamp", now));
        
        // 限制历史记录长度，保留最近的20条消息
        if (history.size() > 20) {
            history = history.subList(history.size() - 20, history.size());
        }
        
        try {
            String json = objectMapper.writeValueAsString(history);
            redisTemplate.opsForValue().set(key, json, Duration.ofDays(7));
            logger.debug("更新会话历史，会话ID: {}, 总消息数: {}", conversationId, history.size());
        } catch (JsonProcessingException e) {
            logger.error("序列化对话历史出错: {}, 会话ID: {}", e.getMessage(), conversationId, e);
        }
    }

    private String buildContext(List<SearchResult> searchResults) {
        if (CollectionUtils.isEmpty(searchResults)) return "";

        final int MAX_SNIPPET_LEN = 300; // 单段最长字符数，超出截断
        StringBuilder context = new StringBuilder();
        for (int i = 0; i < searchResults.size(); i++) {
            SearchResult result = searchResults.get(i);
            String snippet = result.getTextContent();
            if (snippet.length() > MAX_SNIPPET_LEN) {
                snippet = snippet.substring(0, MAX_SNIPPET_LEN) + "…";
            }
            String fileLabel = result.getFileName() != null ? result.getFileName() : "unknown";
            context.append(String.format("[%d] (%s) %s\n",
                    i + 1,
                    Optional.ofNullable(result.getFileName()).orElse("未知文件"),
                    snippet));
        }
        return context.toString();
    }

    private void safeSend(WebSocketSession session, Object payload) {
        try {
            if (session != null && session.isOpen()) {
                String json = objectMapper.writeValueAsString(payload);
                session.sendMessage(new TextMessage(json));
            }
        } catch (Exception e) {
            logger.error("WebSocket 发送失败", e);
        }
    }

    private void sendResponseChunk(WebSocketSession session, String chunk) {
        if (Boolean.TRUE.equals(stopFlags.get(session.getId()))) return;
        safeSend(session, Map.of("chunk", chunk));
    }

    private void sendCompletionNotification(WebSocketSession session) {
        safeSend(session, Map.of(
                "type", "completion",
                "status", "finished",
                "message", "响应已完成",
                "timestamp", System.currentTimeMillis(),
                "date", java.time.LocalDateTime.now().toString()));
    }

    private void handleError(WebSocketSession session, Throwable error) {
        logger.error("AI 流程异常", error);
        safeSend(session, Map.of("error", "AI 助手暂时无法响应，请稍后再试"));
    }

    /**
     * 停止响应 
     */
    public void stopResponse(String userId, WebSocketSession session) {
        String sessionId = session.getId();
        logger.info("收到停止请求，用户ID: {}, 会话ID: {}", userId, sessionId);
        
        // 设置停止标志
        stopFlags.put(sessionId, true);
        
        // 发送停止确认
        safeSend(session, Map.of(
                "type", "stop",
                "message", "已停止生成",
                "timestamp", System.currentTimeMillis(),
                "date", java.time.Instant.now().toString()
        ));


        // 异步清理标志位，确保当前还在飞的 chunk 被丢弃后彻底释放内存
        CompletableFuture.runAsync(() -> {
            try { TimeUnit.SECONDS.sleep(1); } catch (Exception ignore) {}
            stopFlags.remove(sessionId);
        });
        

    }
}
